\section{Roboterbau}

In diesem Teil werden die einzelnen Schritte beschrieben, um den Roboter zu bauen. Dabei wird sich an dem Konzept von \acrshort{pren1} orientiert. Falls von dem Konzept abgewichen wird, wird dies erwähnt und begründet.

Die folgenden Kapitel sind unterteilt nach den einzelnen Funktionen des Roboters. Dabei werden die Tätigkeiten beschrieben, inklusive Testprotokolle und -beschriebe.

TODO: Risikoverweise (welches Risiko vermindert/behoben? \\
TODO: Testprotokolle \\
TODO: Lessons Learned \\
TODO: Komponentendiagramme mit Schnittstellen falls sinnvoll \\

\subsection{Produktbeschreibung}

In diesem Kapitel wird der Roboter als Gesamtsystem beschrieben. Dabei wird das Funktionsmuster mit einem Ablaufdiagramm beschrieben und die einzelnen physischen und elektronischen Komponenten werden in einer Zeichnung, respektive einem Blockdiagramm aufgezeigt.



Damit dieses Funktionsmuster umgesetzt werden kann, wird ein Produkt mit folgenden Komponenten auf Grafik \ref{fig:components} gebaut. Die Grafik ist zeigt lediglich das Konzept mit den nötigen Komponenten und nicht das tatsächliche Aussehen des Roboters.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{assets/gesamtkonzept/Skizze-Fahrzeugkonzept-Beschriftet.jpg}
\caption{Komponenten des Roboters}
\label{fig:components}
\end{figure}

Es wurde folgender Roboter gebaut, der die geplanten Komponeneten enthaelt.
TODO BILD ROBOTER

Die folgende Grafik \ref{fig:ablauf} zeigt den geplanten Ablauf auf. Dieses Ablaufdiagramm stammt aus \acrshort{pren1} und dient zur Erinnerung, genauere Informationen koennen aus der angehaengten PREN 1 Dokumentation entnommen werden.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{assets/gesamtkonzept/ablaufdiagramm.png}
\caption{Gesamtkonzept Ablaufdiagram}
\label{fig:ablauf}
\end{figure}


Die einzelnen elektronischen Teile im Roboter bilden das Gesamtsystem ersichtlich auf Grafik \ref{fig:electro-components}. Dieses sorgt dafür, dass sich der Roboter wie geplant autonom fortbewegen kann.  Die Graphik ist aufgeteilt in die Teile, die Teil der Navigation sind und diese, die Teil der Steuerung sind. 

Das PCBA ist die zentrale Verbindung.  Der TinyK22 liest den Ultraschall, Liniensensor, die Encoder  und die Endschalter des Greifers aus und steuert den Servomotor und die Motorentreiben. Der Raspberry Pi und der TinyK22 kommunizieren ueber UART. Der Raspberry Pi steuert die Kamera an und liest den Startknopf und den Zielasuwahlknops an und zeigt auf dem Disaply das geawhlte Ziel und die Zeit an, die seit dem Start vergangen ist.

TODO speerate graphic to have nav/steuerung

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{assets/gesamtkonzept/electronics.png}
\caption{Elektronische Komponenten des Roboters}
\label{fig:electro-components}
\end{figure} 

\newpage

\subsection{Mechanische Komponenten}
\label{Mechanische Komponenten}

\subsubsection{Fahrwerk konstruieren}
\label{Fahrwerk konstruieren}

 Das Konzept für das Fahrwerk und die Grundplatte wurden analog zum Konzept aus \acrshort{pren1} umgesetzt. Am Fahrwerk wurden gegenüber des Prototyps aus \acrshort{pren1} einzig der Motorflansch und der Lenkrollenhalter angepasst. 
 Beim Prototyp in PREN 1 hat sich gezeigt, dass eine reine Presspassung für die Befestigung der Lenkrolle im Lenkrollenhalter aus PLA nicht ausreichend ist. Aus diesem Grund wird die Lenkrolle jetzt mithilfe eines M4 Gewindestifts geklemmt, wie gezeigt auf Abb.\ref{fig: Lenkrollenhalter V2} 

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{assets/MT/Lenkrollenhalter V2.png}
\caption{Lenkrollenhalter V2}
\label{fig: Lenkrollenhalter V2}
\end{figure}

Der Motorflansch wurde für den finalen Roboter leicht verstärkt. In  Abb. \ref{fig: Motorflansch V1/V2} sieht man in gelb die erste Version des Motorflansches wie er in PREN 1 verbaut wurde. Blau eingefärbt ist die finale Version des Flansches mit einer Verstrebung. 

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{assets/MT/Motorflansch Vergleich.png}
\caption{Motorflansch V1/V2}
\label{fig: Motorflansch V1/V2}
\end{figure}

Die elektronischen Komponenten wie DC/DC-Konverter, Motortreiber oder RasberryPi werden nicht direkt auf die Grundplatte montiert, sondern auf Träger, welche anschliessend auf die Grundplatte geschraubt werden. Die Träger wurden so konstruiert, dass die Kabel zwischen Träger und Bauteilen geführt werden können. (siehe Abb.\ref{fig: Träger für elektronische Komponenten}) Dieser Aufbau hatte in der frühen Testphase den Vorteil, dass alle elektronischen Komponenten provisorisch platziert werden konnten, ohne einen Kurzschluss zu riskieren. 

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{assets/MT/Träger El Komponenten.jpg}
\caption{Träger für elektronische Komponenten werden zur Kabelführung verwendet}
\label{fig: Träger für elektronische Komponenten}
\end{figure}

Das Batteriefach wurde so konstruiert das sich die Batterie für die Lagerung jederzeit entfernen lässt. Dafür wurde ein Click-Verschluss verwendet. Das Batteriefach wird von unten in die Grundplatte geschoben bis es einrastet. Zum Herausnehmen der Batterie müssen nur die Haken gedrückt werden und das Batteriefach kann ausgefahren werden. Um die Funktion problemlos zu gewährleisten dürfen die Wandstärken nicht zu gross sein. Das die Festigkeit trotzdem gewährleistet werden kann wurde die Layerrichtung im 3D Drucker, wie in Abb. \ref{Layerrichtung Batteriefach} so gewählt das die Layer horizontal zur Verschiebung der Hacken angeordnet sind. 


\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{assets/MT/Layer_Batterie Fach.png}
\caption{Layerrichtung Batteriefach}
\label{Layerrichtung Batteriefach}
\end{figure}

\subsubsection{Greifer konstruieren}
\label{Greifer konstruieren}

Der Klemm- und Hebemechanismus des Greifers sind abhängig von der Federkraft und den Lagerstellen. Bei der Implementierung des Greifers musste darauf geachtet werden, dass die Lagerstellen nicht verschoben werden. In Abb \ref{fig:Greifer im Roboter} \& \ref{fig:Greifer Versuchsaufbau} sieht man die für die Funktion wichtigsten Masse am Versuchsaufbau und am fertigen Roboter. Die für die Haltekraft verantwortliche Feder, sowie alle Haltebacken und Pendelstützen wurden vom Prototyp wiederverwendet. 

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[height=5cm]{assets/MT/Greifer Montiert.png}
    \caption{Greifer im Roboter}
    \label{fig:Greifer im Roboter}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[height=5cm]{assets/MT/Greifer Prototyp.png}
    \caption{Greifer Versuchsaufbau}
    \label{fig:Greifer Versuchsaufbau}
  \end{minipage}
\end{figure}

\newpage

\subsubsection{Halterung Liniensensor}
\label{Halterung Liniensensor}

Der Liniensensor wird mit einer zweiteiligen Halterung befestigt. Auf der inneren Schale, in Abb. \ref{fig:Schnitt Halterung Liniensensor} blau, ist der Sensor befestigt. Die innere Schale lässt sich verschieben. So kann die Höhe eingestellt werden. Die Fixierung erfolgt mithilfe von zwei Gewindestiften die in der äusseren Schale befestigt werden und die innere Schale klemmen. 


\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{assets//MT/Sensor Halterung.png}
    \caption{Schnitt Halterung Liniensensor}
    \label{fig:Schnitt Halterung Liniensensor}
\end{figure}


\subsubsection{Abschirmung des Liniensensors}
\label{Abschirmung des Liniensensors}

Um Störungen durch Fremdlicht zu verhindern wurde eine Abdeckung konstruiert, die jegliche Fremdeinstrahlung abschirmt. Als Dichtung wurde ein Bürstenband verwendet, wie es üblicherweise bei Schiebetüren zum Einsatz kommt. Die Bürsten werden in der Halterung eingesteckt und mit einem Geweindestift geklemmt. 


\begin{figure}
    \centering
    \includegraphics[width=0.75\linewidth]{assets//MT/Sensor Abdeckung.png}
    \caption{Sensor Abdeckung}
    \label{fig:Sensor Abdeckung}
\end{figure}
\newpage

\subsubsection{Kamerahalterung}
\label{Kamera Halter}

Der Winkel und die Höhe der Kamera wurden in \acrshort{pren1} an dem Testaufbau in Abb.\ref{fig:Testaufbau zum Festlegen des Kamerawinkels} getestet. Am Testaufbau konnte der Winkel zwischen der Kamera und der Vertikalen mit Hilfe einer Schraube verstellt werden. Der Winkel wurde so gewählt, dass er für die Bildverarbeitung ideal ist. 

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{assets/MT/camer_tower_2.png}
\caption{Testaufbau zum Festlegen des Kamerawinkels}
\label{fig:Testaufbau zum Festlegen des Kamerawinkels}
\end{figure}


Bei der Konstruktion der Kamerabefestigung wurde darauf geachtet, dass der Winkel wie im Testaufbau gemessen 23\textdegree\ beträgt. Ebenfalls wichtig ist, dass die Linsenhöhe 242mm über dem Boden beträgt. 

 \begin{figure}[H]
\centering
\includegraphics[width= \textwidth ]{assets/MT/Sichtfeld_Roboter.png}
\caption{Skizze der Funktionsmasse für die Kamerabefestigung}
\label{fig:Skizze der Funktionsmasse für die Kamerabefestigung}
\end{figure}

%%%%%%%%%%%%%%%%%Epic 1%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Fortbewegung mit geregelter Geschwindigkeit}

\subsubsection{Print Circuit Board Design}
\label{pcb}

Um eine zuverlässige Kontaktierung der einzelnen Komponenten sicherzustellen, wird im Rah-
men von \acrshort{pren2} ein Verbindungs-PCB, ersichtlich auf Grafik \ref{fig: Verteiler PCB}, entwickelt. Dieses \acrshort{pcb} übernimmt das Management der
Spannungsversorgung für den Raspberry Pi und den \gls{tinyk22}. Zudem werden sämtliche Signale,
die vom \gls{tinyk22} erfasst und verarbeitet werden sollen, entsprechend verbunden.

\begin{figure}[H]
\centering
\includegraphics[width=5cm, height=6cm]{assets/ET/PCB/VerteilerPCB_unbestueckt.png}
\caption{Verteiler PCB}
\label{fig: Verteiler PCB}
\end{figure}

Von dem PCB wurden fünf Exemplare bestellt. Ebenso sind von dem \gls{tinyk22} mehrere Exemplare vorhanden. Das PCB zusammen mit dem \gls{tinyk22} ist auf Grafik \ref{fig: Verteiler PCBA} gezeigt. Somit ist das Risiko der kaputten Elektroteile nicht mehr relevant.

\begin{figure}[H]
\centering
\includegraphics[width=5cm, height=6cm]{assets/ET/PCB/VerteilerPCB_bestueckt.png}
\caption{Verteiler PCBA}
\label{fig: Verteiler PCBA}
\end{figure}


\subsubsection{Software Grundlage}

Als Grundlage der Software, dient das Projekt vom Modul Microcontroller Fundamentals. Dieses Projekt beinhaltet ein gutes Grundgerüst. Man hat diverse Codeabschnitte abgeändert, entfernt oder neu hinzugefügt. Als Entwicklungsumgebung wurde MCUXpresso verwendet. Anhand der Pinout Belegungen Abb. \ref{fig:Pinout TinyK22} und Abb. \ref{fig:Pinout Raspy Hat} konnte man diese in der Software initialisieren.

\subsubsection{Servomotor für Greifer} Der Servomotor wurde bereits in Pren 1 getestet und dokumentiert. Durch die Ergebnisse von diesem Test konnte die Software erfolgreich implemenetiert werden.

\newpage

\begin{figure}[h]
\centering
\begin{minipage}[b]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{assets/ET/Software/Tiny_Pinout.png}
  \caption{Pinout Tiny K22}
  \label{fig:Pinout TinyK22}
\end{minipage}
\hspace{0.05\textwidth} % Abstand zwischen den Bildern
\begin{minipage}[b]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{assets/ET/Software/RaspyHat_Pinout.png}
  \caption{Pinout Raspy Hat}
  \label{fig:Pinout Raspy Hat}
\end{minipage}
\end{figure}


TODO ULTRASCHALL IVAN

TODO Leistunsberechnung/AKKU


\subsubsection{Motoren ansteueren und auslesen}
\label{motoren-encoder}
TODO PIN belegung wechseln in pren2



Nachdem die erste Ausführung der Software für die Motoren mit den beiden Encodern vorhanden war, wurde der implementierte Code mithilfe eines provisorischen Aufbaus getestet. Unter einem provisorischen Aufbau versteht man die Verwendung eines Breadboards mit dem \gls{tinyk22} und einem Speisegerät. Dies ist auf Abbildung \ref{fig: Motorentest} ersichtlich.

\begin{figure}[H]
\centering
\includegraphics[width=10cm, height=8cm]{assets/ET/Motoren/Motorentest.jpeg}
\caption{Motorentest}
\label{fig: Motorentest}
\end{figure}


Allerdings kam bereits der Motortreiber zum Einsatz, der auch im späteren Endprodukt verbaut werden soll. Nach anfänglichen Schwierigkeiten bei der Initialisierung des Quadratur-Encoder-Modus auf dem \gls{tinyk22} konnten die ersten Meter erfolgreich zurückgelegt werden. Der zugrunde liegende Fahralgorithmus basiert darauf, die Werte beider Encoder zu mitteln, um die gefahrene Strecke zu ermitteln (siehe Gleichung~\ref{eq:gefahren}).

\begin{equation}
    gefahrenMEAN_{cm} = \frac{gefahrenR_{cm} + gefahrenL_{cm}} {2} 
    \label{eq:gefahren}
\end{equation}

Mit den ersten Erkenntnissen aus dem Test konnte die Software weiter angepasst werden, um immer präzisere Fahrmanöver auszuführen. 

Bei den Drehversuchen konnte kein Winkel kleiner als 90\textdegree \ realisiert werden. Die Ursache wurde zunächst in der Softwareimplementierung vermutet, woraufhin gezielt nach möglichen Fehlerquellen gesucht wurde. Es wurde erheblicher Aufwand in die Entwicklung und den Vergleich verschiedener Auslesealgorithmen sowie in die Fehlersuche im bestehenden Code investiert. Trotz dieser Maßnahmen konnte jedoch keine signifikante Verbesserung erzielt werden.

TODO: Folgender Text mit Tabellen ist eigentlich der Testbericht. (Anpassen?)

Die Hardware sowie der zugehörige Code wurde auf Fehler überprüft. Mit dem Oszilloskop wurden die vom Encoder erzeugten Signale analysiert. Dabei zeigte sich ein hochfrequentes Rauschen, dessen Amplituden jedoch zu gering sind, um nennenswerte Fehler zu verursachen. Die Ursache des Rauschens konnte auf die verwendeten DC-Motoren zurückgeführt werden.

Anschliessend wurde ein Encoder mithilfe eines Frequenzgenerators simuliert, um das Zähleverhalten des implementierten Codes zu überprüfen. Die Taktfrequenz wurde auf 500 Hz eingestellt. Kanal 2 wurde mit einer Phasenverschiebung von 90\textdegree \ nacheilend konfiguriert. Unter diesen Bedingungen sollte der implementierte Zähler eine Inkrementierung vornehmen.

Das Taktsignal wurde für eine Dauer von 2 Sekunden angelegt, was direkt am Frequenzgenerator eingestellt wurde. Der erwartete Endwert des Zählers lag entsprechend bei etwa 1000.

\begin{table}[ht]
\centering
\caption{Ergebnisse der aufgezeichneten Taktimpulse Decoder}
\label{tab:taktergebnisse_de}
\begin{tabular}{|c|c|}
\hline
\textbf{Messung} & \textbf{Aufgezeichnete Takte} \\
\hline
1 & 723 \\
2 & 1397 \\
3 & 1412 \\
4 & 655 \\
\hline
\end{tabular}
\end{table}

Wie aus Tabelle \ref{tab:taktergebnisse_de} ersichtlich ist, weichen die aufgezeichneten Werte um bis zu 41\% vom erwarteten Sollwert ab. Diese Abweichung ist zu gross, um eine präzise Regelung darauf aufzubauen.

Es wurde ebenfalls der Code des MCCAR untersucht. Der Code liest die Encoder auf eine andere Weise aus. Anstelle der integrierten Decoder wurde ein eigener Decoder implementiert. Dazu wird das Input Capture verwendet. Dies hat den Vorteil, dass die Geschwindigkeit der einzelnen Räder berechnet werden kann.

Diese genaueren Tests erfolgten erst, nachdem entschieden wurde das man mit diesen Motoren/Encodern weiter arbeitet. In den ersten Tests zweifelte man immer den eigenen Leistungen und nicht einer schlechten Hardware, darum wurde in die Encoder zu viel Zeit reingesteckt die sich nicht ausbezahlt hat.

\begin{table}[ht]
\centering
\caption{Ergebnisse der aufgezeichneten Taktimpulse Input Capture}
\label{tab:taktergebnisse_im}
\begin{tabular}{|c|c|}
\hline
\textbf{Messung} & \textbf{Aufgezeichnete Takte} \\
\hline
1 & 902 \\
2 & 1252 \\
3 & 842 \\
4 & 876 \\
\hline
\end{tabular}
\end{table}

Die Abweichung beim Input Capture ist geringer als bei den integrierten Decodern, liegt jedoch immer noch bei etwa 25\% (siehe Tabelle \ref{tab:taktergebnisse_im}).

\textbf{Endgültige Situation mit Encodern}

Aufgrund der hohen Fehlerrate beim Auslesen sowie der Vielzahl an Problemen mit den Encodern wurde entschieden, die Drehung ausschliesslich mithilfe der Liniensensoren oder mit einer anderen Lösung durchzuführen.



\subsubsection{Gyroskop statt Encoder}

Da mit den geplanten Encodern nicht wie gewollt weiter gekommen ist, musste kurz vor Schluss nach einer Alternative gesucht werden. Man entschied sich ein Gyroskop zu verwenden. Ein Gyroskop reagiert auf Drehbewegungen, die durch die Corioliskraft verursacht wird. Die Corioliskraft bringt eine Masse ins Schwingen, so kann die Drehbewegung detektiert werden \parencite{zielke2025}. Dieser Sensor wird über \acrshort{iic} angesteuert um die Messdaten zu erlangen. Um die Implementation zu testen, wurde mithilfe eines Logic Analyzers das erste Byte vom Master zum Slave aufgezeichnet. Somit konnte man die Korrektheit der Adresse feststellen \ref{fig:Gyroskop}. 

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{assets/ET/Gyroskop/Gyroskop.png}
\caption{Aufgezeichnetes Byte}
\label{fig:Gyroskop}
\end{figure}


Nach dem man sichergestellt hat das der Master (\gls{tinyk22}) die richtige Adresse anspricht, konnte der Gyrosensor ausgelesen werden. Für den Test wurde er bereits fest auf den Roboter angeschlossen und montiert, wie in Abb. \ref{fig:Gyroskop auf dem Roboter} unten links zu sehen ist. Es sind jeweils 2 Bytes pro Achse, die die Drehgeschwindigkeit angeben. Jedoch musste feststellt werden, dass sich diese Werte zu sehr unterscheiden und nicht zu einen exakten Winkel berechnen lassen. Die Werte liessen sich schon durch leichte Vibration stark verändern.  Infolge dieser Ungenauigkeit konnte auch mit diesem Bauteil nicht weiter gearbeitet werden.


\begin{figure}[h]
\centering
\includegraphics[width=5cm, height=7cm]{assets/ET/Gyroskop/Gyro_Montiert.jpeg}
\caption{Festmontierter Gyrosensor auf dem Roboter}
\label{fig:Gyroskop auf dem Roboter}
\end{figure}



%%%%%%%%%%%%%%%%%Epic 2%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Auf Linien des Graphes bewegen}
\label{Auf Linien des Graphes bewegen}

\subsubsection{Liniensensor auslesen}
\label{Liniensensor auslesen}

In einem ersten Durchlauf wurde ein Code implementiert, um die Funktion mit dem \gls{tinyk22} zu testen. Mittels eines Timers wurden die einzelnen Pins in einem genügend grossen Zeitabstand von \acrfull{vcc} auf Input Capture umgeschaltet. Nach dem Umschalten auf Input Capture, sollten sich die Kondensatoren je nach Reflektion des Untergrundes in unterschiedlichen Zeiten laden. Dieses Verhalten konnte im Testprogramm dann auch erfolgreich festgestellt werden durch die unterschiedlichen Werte im Timer Register des Input Capture Modus.


\subsubsection{Linie folgen mit PD-Regelung}
\label{Linie folgen mit PD-Regelung}

Nachdem die Auslesung des Liniensensors erfolgreich getestet wurde, konnte die eigentliche Linienregelung implementiert werden, wovon ein Ausschnitt auf Abb. \ref{fig:Ausschnitt der Implementation der PD-Regelung} ersichtlich ist. Damit möglichst dynamisch und mit möglichst wenig Schwingungen gefahren werden kann, wurde ein PD-Regler ausgewählt. Bei jedem Neustart des Roboters, liest eine Kalibrierungsfunktion die Soll-Werte der einzelnen Sensoren ein. Beim Kalibrieren muss der Roboter immer in seiner Soll-Fahrposition stehen. Die periodisch aufgerufene Reglerfunktion berechnet dann aus dem Soll-Wert und dem aktuellen Sensorwert (Ist-Wert) die Abweichung. Diese Fehler werden zu einem Gesamtfehler mit einer Gewichtung der Sensoren von aussen nach innen zunehmend berechnet. Dieser Gesamtfehler wird dann mit dem P- und D-Anteil zu einem Korrekturwert weiter verrechnet. Der Proportionalanteil (P) sorgt dafür, dass das Fahrzeug bei einem grösseren Fehler stärker korrigiert, während der Differentialanteil (D) auf schnelle Änderungen des Fehlers reagiert und so Schwingungen dämpft. Der Korrekturwert wird dann genutzt um die beiden \acrfull{pwm} Signale der Motoren zu senken oder erhöhen, je nach Abweichung zur Linie.

 \begin{figure}[H]
\centering
\includegraphics[width= \textwidth ]{assets/ET/PD-Regler/PD-Regler_Code_Pren2.png}
\caption{Ausschnitt der Implementation der PD-Regelung}
\label{fig:Ausschnitt der Implementation der PD-Regelung}
\end{figure}


\subsubsection{Liniensensor mit Abschirmung anbringen}

Nach dem ersten Test wurde der Liniensensor am Fahrzeug mit der Abschirmung angebracht (siehe Abb. \ref{fig:enter-label}). Dank diesem Aufbau konnte mit der weiteren Implementierung fortgefahren werden. Für die Feineinstellung wurden die einzelnen Sensorwerte auf dem Originalboden und dem Klebeband ausgemessen, da dies essenziell ist, um die Regelung sauber abzustimmen.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Sensor montiert.png}
    \caption{Sensor montiert}
    \label{fig:enter-label}
\end{figure}


\newpage
%%%%%%%%%%%%%%%%%Epic 3%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Bis zum nächsten Knoten fahren}

\subsubsection{Liniensensor}

Die Liniensensoren wurden wie geplant implementiert. Durch das Ummuxen der Pins von GPIO-Output (High) auf den Input Capture Modus, wird die Ladezeit eines Kondensators gemessen. Diese Zeit (ausgedrückt in Ticks) liefert Informationen darüber, ob sich das Fahrzeug über dem Soll-Fahrweg befindet oder davon abweicht. Während der Fahrt werden die Sensor-Pins periodisch zwischen GPIO High und Input Capture umgeschaltet, um kontinuierlich neue Messwerte zu erhalten. Die erfassten Ticks werden in einer PD-Regelung weiter verarbeitet, welche die Abweichung zur Soll-Position (Linie) berechnet und entsprechend die Motoren nachsteuert. Diese Regelung ergänzt die Wegmessung über die Encodersensoren und erhöht die Spurtreue, indem sie sicherstellt, dass das Fahrzeug die Linie nicht verlässt. Das Erkennen ob der Roboter auf einem Wegpunkt steht oder nicht, wird ebenfalls mittels der Sensorenwerte geprüft. Da beim erreichen des Wegpunktes im Optimalfall alle Sensoren auf der weissen Oberfläche stehen, weichen die Werte der aktuellen Ticks stark der Sollwerte ab. Somit kann ein Wegpunkt klar identifiziert werden und der Roboter kann anhalten.



