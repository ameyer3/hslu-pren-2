\section{Roboterbau}

In diesem Teil werden die einzelne Schritte beschrieben, um den Roboter zu bauen. Dabei wird sich an dem Konzept von \acrshort{pren1} orientiert. Falls von dem Konzept abgewichen wird, wird dies erwähnt und begründet. Die Arbeit aus \acrshort{pren1} kann im elektronischen Anhang gefunden werden.

Die folgenden Kapitel sind unterteilt nach den einzelnen Funktionen des Roboters. Dabei werden die Tätigkeiten beschrieben, inklusive Testprotokolle und -beschriebe.

TODO: Risikoverweise (welches Risiko vermindert/behoben? \\
TODO: Testprotokolle \\
TODO: Lessons Learned \\
TODO: Komponentendiagramme mit Schnittstellen falls sinnvoll \\

\subsection{Produktbeschreibung}

In diesem Kapitel wird der Roboter als Gesamtsystem beschrieben. Dabei wird das Funktionsmuster mit einem Ablaufdiagramm beschrieben und die einzelnen physischen und elektronischen Komponenten werden in einer Zeichnung, respektive einem Blockdiagramm aufgezeigt.


Die folgende Grafik \ref{fig:ablauf} zeigt das geplante Funktionsmuster auf. Dieses Ablaufdiagramm stammt aus \acrshort{pren1} und dient zur Erinnerung, genauere Informationen koennen aus der angehaengten PREN 1 Dokumentation entnommen werden.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{assets/gesamtkonzept/ablaufdiagramm.png}
\caption{Gesamtkonzept Ablaufdiagram}
\label{fig:ablauf}
\end{figure}

Damit dieses Funktionsmuster umgesetzt werden kann, wird ein Produkt mit folgenden Komponenten auf Grafik \ref{fig:components} gebaut. Die Grafik ist zeigt lediglich das Konzept mit den noetigen Komponenten und nicht das tatsaechliche Aussehen des Roboters.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{assets/gesamtkonzept/Skizze-Fahrzeugkonzept-Beschriftet.jpg}
\caption{Komponenten des Roboters}
\label{fig:components}
\end{figure}

Die einzelnen elektronischen Teile im Roboter bilden das Gesamtsystem ersichtlich auf Grafik \ref{fig:electro-components}. Dieses sorgt dafuer, dass sich der Roboter wie geplant autonom fortbewegen kann.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{assets/gesamtkonzept/electronics.png}
\caption{Elektronische Komponenten des Roboters}
\label{fig:electro-components}
\end{figure} 

\newpage

%%%%%%%%%%%%%%%%%Epic 1%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Fortbewegung mit geregelter Geschwindigkeit}

\subsubsection{Print Circuit Board Design}
\label{pcb}

Um eine zuverlässige Kontaktierung der einzelnen Komponenten sicherzustellen, wird im Rah-
men von \acrshort{pren2} ein Verbindungs-PCB, ersichtlich auf Grafik\ref{fig: Verteiler PCB}, entwickelt. Dieses \acrshort{pcb} übernimmt das Management der
Spannungsversorgung für den Raspberry Pi und den TinyK22. Zudem werden sämtliche Signale,
die vom TinyK22 erfasst und verarbeitet werden sollen, entsprechend verbunden.

\begin{figure}[H]
\centering
\includegraphics[width=5cm, height=6cm]{assets/ET/PCB/VerteilerPCB_unbestueckt.png}
\caption{Verteiler PCB}
\label{fig: Verteiler PCB}
\end{figure}

Von dem PCB wurden fünf Exemplare bestellt. Ebenso sind von dem TinyK22 mehrere Exemplare vorhanden. Das PCB zusammen mit dem Tiny K22 ist auf Grafik \ref{fig: Verteiler PCBA} gezeigt. Somit ist das Risiko der kaputten Elektroteile nicht mehr relevant.

\begin{figure}[H]
\centering
\includegraphics[width=5cm, height=6cm]{assets/ET/PCB/VerteilerPCB_bestueckt.png}
\caption{Verteiler PCBA}
\label{fig: Verteiler PCBA}
\end{figure}


\subsubsection{Motoren ansteueren und auslesen}

Nachdem die erste Ausführung der Software für die Motoren mit den beiden Encodern vorhanden war, wurde der implementierte Code mithilfe eines provisorischen Aufbaus getestet. Unter einem provisorischen Aufbau versteht man die Verwendung eines Breadboards mit dem TinyK22 und einem Speisegerät. Dies ist auf Abbildung \ref{fig: Motorentest} ersichtlich.

\begin{figure}[H]
\centering
\includegraphics[width=10cm, height=8cm]{assets/ET/Motoren/Motorentest.jpeg}
\caption{Motorentest}
\label{fig: Motorentest}
\end{figure}


Allerdings wurde bereits der ausgewählte Motortreiber verwendet, der später auch im Endprodukt verbaut wird. Nach einigen Schwierigkeiten bei der Initialisierung des Quadratur-Encoder-Modus auf dem TinyK22 konnten die ersten Meter erfolgreich gefahren werden. Mit den ersten Erkenntnissen aus dem Test konnte die Software weiter angepasst werden, um immer präzisere Fahrmaneuver auszuführen.

\textbf{Endgültige Situation mit Encodern}

Die Encoder sowie der zugehörige Code wurden auf Fehler überprüft. Mit dem Oszilloskop wurden die vom Encoder erzeugten Signale analysiert. Dabei zeigte sich ein hochfrequentes Rauschen, dessen Amplituden jedoch zu gering sind, um nennenswerte Fehler zu verursachen. Die Ursache des Rauschens konnte auf die verwendeten DC-Motoren zurückgeführt werden.

Anschliessend wurde ein Encoder mithilfe eines Frequenzgenerators simuliert, um das Zähleverhalten des implementierten Codes zu überprüfen. Die Taktfrequenz wurde auf 500 Hz eingestellt. Kanal 2 wurde mit einer Phasenverschiebung von 90 Grad nacheilend konfiguriert. Unter diesen Bedingungen sollte der implementierte Zähler eine Inkrementierung vornehmen.

Das Taktsignal wurde für eine Dauer von 2 Sekunden angelegt, was direkt am Frequenzgenerator eingestellt wurde. Der erwartete Endwert des Zählers lag entsprechend bei etwa 1000.

\begin{table}[ht]
\centering
\caption{Ergebnisse der aufgezeichneten Taktimpulse Decoder}
\label{tab:taktergebnisse_de}
\begin{tabular}{|c|c|}
\hline
\textbf{Messung} & \textbf{Aufgezeichnete Takte} \\
\hline
1 & 723 \\
2 & 1397 \\
3 & 1412 \\
4 & 655 \\
\hline
\end{tabular}
\end{table}

Wie aus Tabelle \ref{tab:taktergebnisse_de} ersichtlich ist, weichen die aufgezeichneten Werte um bis zu 41\% vom erwarteten Sollwert ab. Diese Abweichung ist zu gross, um eine präzise Regelung darauf aufzubauen.

Es wurde ebenfalls der Code des MCCAR untersucht. Der Code liest die Encoder auf eine andere Weise aus. Anstelle der integrierten Decoder wurde ein eigener Decoder implementiert. Dazu wird das Input Capture verwendet. Dies hat den Vorteil, dass die Geschwindigkeit der einzelnen Räder berechnet werden kann.

\begin{table}[ht]
\centering
\caption{Ergebnisse der aufgezeichneten Taktimpulse Input Capture}
\label{tab:taktergebnisse_im}
\begin{tabular}{|c|c|}
\hline
\textbf{Messung} & \textbf{Aufgezeichnete Takte} \\
\hline
1 & 902 \\
2 & 1252 \\
3 & 842 \\
4 & 876 \\
\hline
\end{tabular}
\end{table}

Die Abweichung beim Input Capture ist geringer als bei den integrierten Decodern, liegt jedoch immer noch bei etwa 25\% (siehe Tabelle \ref{tab:taktergebnisse_im}).

Aufgrund der hohen Fehlerrate beim Auslesen sowie der Vielzahl an Problemen mit den Encodern wurde entschieden, die Drehung ausschliesslich mithilfe der Liniensensoren oder mit einem Gyroskop durchzuführen.

\subsection{Komponenten}
\label{Komponenten}

\subsubsection{Fahrwerk konstruieren}
\label{Fahrwerk konstruieren}

 Das Konzept für das Fahrwerk und die Grundplatte wurden analog zum Konzept aus \acrshort{pren1} umgesetzt. Am Fahrwerk wurden gegenüber des Prototyps aus \acrshort{pren1} einzig der Motorflansch und der Lenkrollenhalter angepasst. Beim Prototyp in PREN 1 hat sich gezeigt, dass eine reine Presspassung für die Befestigung der Lenkrolle im Lenkrollenhalter aus PLA nicht ausreichend ist. Aus diesem Grund wird die Lenkrolle jetzt mithilfe eines M4 Gewindestifts geklemmt, wie gezeigt auf Abb.\ref{fig: Lenkrollenhalter V2} 

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{assets/MT/Lenkrollenhalter V2.png}
\caption{Lenkrollenhalter V2}
\label{fig: Lenkrollenhalter V2}
\end{figure}

Der Motorflansch wurde für den finalen Roboter leicht verstärkt. In  Abb. \ref{fig: Motorflansch V1/V2} sieht man in gelb die erste Version des Motorflansches wie er in PREN 1 verbaut wurde. Blau eingefärbt ist die finale Version des Flansches mit einer Verstrebung. 

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{assets/MT/Motorflansch Vergleich.png}
\caption{Motorflansch V1/V2}
\label{fig: Motorflansch V1/V2}
\end{figure}

Die elektronischen Komponenten wie DC/DC-Konverter, Motortreiber oder RasberryPi werden nicht direkt auf die Grundplatte montiert, sondern auf Träger, welche anschliessend auf die Grundplatte geschraubt werden. Die Träger wurden so konstruiert, dass die Kabel zwischen Träger und Bauteilen geführt werden können. (siehe Abb.\ref{fig: Träger für elektronische Komponenten}) Dieser Aufbau hatte in der frühen Testphase den Vorteil, dass alle elektronischen Komponenten provisorisch platziert werden konnten, ohne einen Kurzschluss zu riskieren. 

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{assets/MT/Träger El Komponenten.jpg}
\caption{Träger für elektronische Komponenten werden zur Kabelführung verwendet}
\label{fig: Träger für elektronische Komponenten}
\end{figure}

Das Batteriefach wurde so konstruiert das sich die Batterie für die Lagerung jederzeit entfernen lässt. Dafür wurde ein Click-Verschluss verwendet. Das Batteriefach wird von unten in die Grundplatte geschoben bis es einrastet. Zum Herausnehmen der Batterie müssen nur die Haken gedrückt werden und das Batteriefach kann ausgefahren werden. Um die Funktion problemlos zu gewährleisten dürfen die Wandstärken nicht zu gross sein. Das die Festigkeit trotzdem gewährleistet werden kann wurde die Layerrichtung im 3D Drucker, wie in Abb. \ref{Layerrichtung Batteriefach} so gewählt das die Layer horizontal zur Verschiebung der Hacken angeordnet sind. 


\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{assets/MT/Layer_Batterie Fach.png}
\caption{Layerrichtung Batteriefach}
\label{Layerrichtung Batteriefach}
\end{figure}

\subsubsection{Greifer konstruieren}
\label{Greifer konstruieren}

Der Klemm- und Hebemechanismus des Greifers sind Abhängig von der Federkraft und den Lagerstellen. Bei der Implementierung des Greifers musste darauf geachtet werden, dass die Lagerstellen nicht verschoben werden. In Abb \ref{fig:Greifer im Roboter} \& \ref{fig:Greifer Versuchsaufbau} sieht man die für die Funktion wichtigsten Masse am Versuchsaufbau und am fertigen Roboter. Die für die Haltekraft verantwortliche Feder, sowie alle Haltebacken und Pendelstützen wurden vom Prototyp wiederverwendet. 

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[height=5cm]{assets/MT/Greifer Montiert.png}
    \caption{Greifer im Roboter}
    \label{fig:Greifer im Roboter}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \centering
    \includegraphics[height=5cm]{assets/MT/Greifer Prototyp.png}
    \caption{Greifer Versuchsaufbau}
    \label{fig:Greifer Versuchsaufbau}
  \end{minipage}
\end{figure}

\newpage

\subsubsection{Halterung Liniensensor}
\label{Halterung Liniensensor}

Für den Liniensensor wurde eine Halterung erstellt, welche in der Höhe verstellbar ist für eine optimale und flexible Einstellung am Roboter.

Die Konstruktion ist zweiteilig und  besteht aus einem äusseren und einem inneren Teil. Die Halterung wurde mit dem 3D-Drucker ausgedruckt.

Befestigt wurde der äussere Teil mit 4 M3 schrauben an der Grundplatte. Der innere Teil, an dem der Liniensensor befestigt wird, hat ein Untermass und ist so in der Höhe verschiebbar. Mittels M3-Gewindestiften wird er in Position festgeklemmt.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{assets//MT/Sensor Halterung.png}
    \caption{Halterung mit Sensor}
    \label{fig:Halterung mit Sensor}
\end{figure}


\subsubsection{Abschirmung des Liniensensors}
\label{Abschirmung des Liniensensors}
Um Störeinflüsse von aussen zu vermeiden, wurde eine Abdeckung konstruiert, die jegliche Einstrahlung abschirmt. Der Liniensensor funktioniert am besten wenn er in einem abgedunkelten Umfeld eingesetzt wird.

Als Abdeckung werden Bürstendichtungen für Türen verwendet, welche in eine ausgedruckte Aufnahme gesteckt werden und mit Gewindestifte festgeklemmt werden. Die Vorrichtung wird um die Sensorhalterung angebracht und dunkelt so den Sensor ab.

\begin{figure}
    \centering
    \includegraphics[width=0.75\linewidth]{assets//MT/Sensor Abdeckung.png}
    \caption{Sensor Abdeckung}
    \label{fig:Sensor Abdeckung}
\end{figure}
\newpage
%%%%%%%%%%%%%%%%%Epic 2%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Auf Linien des Graphes bewegen}

\subsubsection{Liniensensor auslesen}
\label{Liniensensor auslesen}

In einem ersten Durchlauf wurde ein Code implementiert, um die Funktion mit dem Tiny K22 zu testen. Mittels eines Timers wurden die einzelnen Pins in einem genügend grossen Zeitabstand von \acrfull{vcc} auf Input Capture umgeschaltet. Nach dem Umschalten auf Input Capture, sollten sich die Kondensatoren je nach Reflektion des Untergrundes in unterschiedlichen Zeiten laden. Dieses Verhalten konnte im Testprogramm dann auch erfolgreich festgestellt werden durch die unterschiedlichen Werte im Timer Register des Input Capture Modus.


\subsubsection{Linie folgen mit PD-Regelung}

Nachdem die Auslesung des Liniensensors erfolgreich getestet wurde, konnte die eigentliche Linienregelung implementiert werden, wovon ein Ausschnitt auf Abb. \ref{fig:Ausschnitt der Implementation der PD-Regelung} ersichtlich ist. Damit möglichst dynamisch und mit moeglichst wenig Schwingungen gefahren werden kann, wurde ein PD-Regler ausgewählt. Bei jedem Neustart des Roboters, liest eine Kalibrierungsfunktion die Soll-Werte der einzelnen Sensoren ein. Beim Kalibrieren muss der Roboter immer in seiner Soll-Fahrposition stehen. Die periodisch aufgerufene Reglerfunktion berechnet dann aus dem Soll-Wert und dem aktuellen Sensorwert (Ist-Wert) die Abweichung. Diese Fehler werden zu einem Gesamtfehler mit einer Gewichtung der Sensoren von aussen nach innen zunehmend berechnet. Dieser Gesamtfehler wird dann mit dem P- und D-Anteil zu einem Korrekturwert weiter verrechnet. Der Proportionalanteil (P) sorgt dafür, dass das Fahrzeug bei einem grösseren Fehler stärker korrigiert, während der Differentialanteil (D) auf schnelle Änderungen des Fehlers reagiert und so Schwingungen dämpft. Der Korrekturwert wird dann genutzt um die beiden \acrfull{pwm} Signale der Motoren zu senken oder erhöhen, je nach Abweichung zur Linie.

 \begin{figure}[H]
\centering
\includegraphics[width= \textwidth ]{assets/ET/PD-Regler/PD-Regler_Code_Pren2.png}
\caption{Ausschnitt der Implementation der PD-Regelung}
\label{fig:Ausschnitt der Implementation der PD-Regelung}
\end{figure}


\subsubsection{Liniensensor mit Abschirmung anbringen}

Nach dem ersten Test wurde der Liniensensor am Fahrzeug mit der Abschirmung angebracht (siehe Abb. \ref{fig:enter-label}. Dank diesem Aufbau konnte mit der weiteren Implementierung fortgefahren werden. Für die Feineinstellung wurden die einzelnen Sensorwerte auf dem Originalboden und dem Klebeband ausgemessen, da dies essenziell ist, um die Regelung sauber abzustimmen.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Sensor montiert.png}
    \caption{Sensor montiert}
    \label{fig:enter-label}
\end{figure}


\newpage
%%%%%%%%%%%%%%%%%Epic 3%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Bis zum nächsten Knoten fahren}

\subsubsection{Liniensensor}

Die Liniensensoren wurden wie geplant implementiert. Durch das Ummuxen der Pins von GPIO-Output (High) auf den Input Capture Modus, wird die Entladezeit eines Kondensators gemessen. Diese Zeit (ausgedrückt in Ticks) liefert Informationen darüber, ob sich das Fahrzeug über dem Soll-Fahrweg befindet oder davon abweicht. Während der Fahrt werden die Sensor-Pins periodisch zwischen GPIO High und Input Capture umgeschaltet, um kontinuierlich neue Messwerte zu erhalten. Die erfassten Ticks werden in einer PD-Regelung weiter verarbeitet, welche die Abweichung zur Soll-Position (Linie) berechnet und entsprechend die Motoren nachsteuert. Diese Regelung ergänzt die Wegmessung über die Encodersensoren und erhöht die Spurtreue, indem sie sicherstellt, dass das Fahrzeug die Linie nicht verlässt.

TODO JONAH LINIENSENSOR ERREICHT UND ERKENNT KNOTEN